<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Các Cấu Trúc Dữ Liệu trong Dự Án Node.js</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 text-gray-800 font-sans">
  <div class="container mx-auto p-8">
    <h1 class="text-4xl font-semibold text-center text-blue-600 mb-8">Hiểu về Các Cấu Trúc Dữ Liệu trong Dự Án Node.js</h1>
    
    <!-- Giới thiệu -->
    <section class="mb-8">
      <p class="text-lg text-gray-700">
        Trang này giải thích các cấu trúc dữ liệu phổ biến và cách chúng có thể được áp dụng trong các dự án thực tế
        sử dụng <strong>Node.js</strong>, <strong>Express</strong>, và <strong>TypeScript</strong> với Generics.
      </p>
    </section>

    <!-- Mảng (Array) -->
    <section class="mb-8">
      <h2 class="text-2xl font-semibold text-blue-500">1. Mảng (Array)</h2>
      <p class="text-lg text-gray-700 mb-2">
        Mảng là một cấu trúc dữ liệu lưu trữ một danh sách các phần tử theo thứ tự nhất định. Mảng thường được sử dụng khi bạn cần lưu trữ nhiều mục giống nhau.
      </p>
      <pre class="bg-gray-100 p-4 rounded-md mt-4 text-sm">
const users: Array<{ id: number; name: string }> = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' }
];
console.log(users.map(user => user.name)); // ['Alice', 'Bob']
      </pre>
    </section>

    <!-- Đối tượng (Object) -->
    <section class="mb-8">
      <h2 class="text-2xl font-semibold text-blue-500">2. Đối Tượng (Object)</h2>
      <pre class="bg-gray-100 p-4 rounded-md mt-4 text-sm">
interface User {
  id: number;
  name: string;
  age: number;
}

const user: User = {
  id: 1,
  name: 'Alice',
  age: 28
};

console.log(user.name); // "Alice"
      </pre>
    </section>

    <!-- Hash Table -->
    <section class="mb-8">
      <h2 class="text-2xl font-semibold text-blue-500">3. Hash Table (Bảng Băm)</h2>
      <p class="text-lg text-gray-700 mb-2">
        Bảng băm là một cấu trúc dữ liệu ánh xạ giữa khóa và giá trị. Hash table rất hiệu quả trong việc tra cứu nhanh.
      </p>
      <pre class="bg-gray-100 p-4 rounded-md mt-4 text-sm">
class HashTable<K, V> {
  private table: Map<K, V>;

  constructor() {
    this.table = new Map<K, V>();
  }

  insert(key: K, value: V): void {
    this.table.set(key, value);
  }

  search(key: K): V | undefined {
    return this.table.get(key);
  }
}

const hashTable = new HashTable<string, string>();
hashTable.insert('user1', 'Alice');
console.log(hashTable.search('user1')); // "Alice"
      </pre>
    </section>

    <!-- Ngăn xếp (Stack) -->
    <section class="mb-8">
      <h2 class="text-2xl font-semibold text-blue-500">4. Ngăn Xếp (Stack)</h2>
      <pre class="bg-gray-100 p-4 rounded-md mt-4 text-sm">
class Stack<T> {
  private items: T[] = [];

  push(element: T): void {
    this.items.push(element);
  }

  pop(): T | undefined {
    return this.items.pop();
  }
}

const stack = new Stack<number>();
stack.push(10);
stack.push(20);
console.log(stack.pop()); // 20
      </pre>
    </section>

    <!-- Hàng đợi (Queue) -->
    <section class="mb-8">
      <h2 class="text-2xl font-semibold text-blue-500">5. Hàng Đợi (Queue)</h2>
      <pre class="bg-gray-100 p-4 rounded-md mt-4 text-sm">
class Queue<T> {
  private items: T[] = [];

  enqueue(element: T): void {
    this.items.push(element);
  }

  dequeue(): T | undefined {
    return this.items.shift();
  }
}

const queue = new Queue<string>();
queue.enqueue('task1');
queue.enqueue('task2');
console.log(queue.dequeue()); // "task1"
      </pre>
    </section>

    <!-- Set -->
    <section class="mb-8">
      <h2 class="text-2xl font-semibold text-blue-500">6. Set (Tập hợp)</h2>
      <p class="text-lg text-gray-700 mb-2">
        Set là một cấu trúc dữ liệu chứa các phần tử duy nhất, không trùng lặp. Nó rất hữu ích khi bạn cần đảm bảo rằng không có giá trị nào xuất hiện nhiều lần trong bộ dữ liệu.
      </p>
      <pre class="bg-gray-100 p-4 rounded-md mt-4 text-sm">
const numbers = new Set<number>();
numbers.add(1);
numbers.add(2);
numbers.add(2); // Phần tử trùng sẽ không được thêm vào
console.log(numbers); // Set { 1, 2 }

const strings = new Set<string>();
strings.add("Alice");
strings.add("Bob");
strings.add("Alice"); // Phần tử "Alice" đã có, không thêm lại
console.log(strings); // Set { 'Alice', 'Bob' }
      </pre>
    </section>

    <!-- Danh sách liên kết (Linked List) -->
    <section class="mb-8">
      <h2 class="text-2xl font-semibold text-blue-500">7. Danh Sách Liên Kết (Linked List)</h2>
      <pre class="bg-gray-100 p-4 rounded-md mt-4 text-sm">
class Node<T> {
  data: T;
  next: Node<T> | null = null;

  constructor(data: T) {
    this.data = data;
  }
}

class LinkedList<T> {
  head: Node<T> | null = null;

  insert(data: T): void {
    const newNode = new Node(data);
    newNode.next = this.head;
    this.head = newNode;
  }
}

const list = new LinkedList<number>();
list.insert(1);
list.insert(2);
console.log(list.head); // { data: 2, next: { data: 1, next: null } }
      </pre>
    </section>

    <!-- Cây (Tree) -->
    <section class="mb-8">
      <h2 class="text-2xl font-semibold text-blue-500">8. Cây (Tree)</h2>
      <pre class="bg-gray-100 p-4 rounded-md mt-4 text-sm">
class TreeNode<T> {
  value: T;
  left: TreeNode<T> | null = null;
  right: TreeNode<T> | null = null;

  constructor(value: T) {
    this.value = value;
  }
}

class BinaryTree<T> {
  root: TreeNode<T> | null = null;

  insert(value: T): void {
    const newNode = new TreeNode(value);
    if (!this.root) {
      this.root = newNode;
    } else {
      this.insertNode(this.root, newNode);
    }
  }

  insertNode(node: TreeNode<T>, newNode: TreeNode<T>): void {
    if (newNode.value < node.value) {
      if (node.left === null) {
        node.left = newNode;
      } else {
        this.insertNode(node.left, newNode);
      }
    } else {
      if (node.right === null) {
        node.right = newNode;
      } else {
        this.insertNode(node.right, newNode);
      }
    }
  }
}

const tree = new BinaryTree<number>();
tree.insert(10);
tree.insert(5);
tree.insert(15);
console.log(tree.root); // Root node with value 10
      </pre>
    </section>

    <!-- Đồ thị (Graph) -->
    <section class="mb-8">
      <h2 class="text-2xl font-semibold text-blue-500">9. Đồ Thị (Graph)</h2>
      <pre class="bg-gray-100 p-4 rounded-md mt-4 text-sm">
class Graph<T> {
  private adjList: Map<T, T[]> = new Map();

  addVertex(vertex: T): void {
    if (!this.adjList.has(vertex)) {
      this.adjList.set(vertex, []);
    }
  }

  addEdge(vertex1: T, vertex2: T): void {
    this.adjList.get(vertex1)?.push(vertex2);
    this.adjList.get(vertex2)?.push(vertex1);
  }

  getAdjacencyList(): Map<T, T[]> {
    return this.adjList;
  }
}

const graph = new Graph<string>();
graph.addVertex('A');
graph.addVertex('B');
graph.addEdge('A', 'B');
console.log(graph.getAdjacencyList()); // Map { 'A' => [ 'B' ], 'B' => [ 'A' ] }
      </pre>
    </section>

    <!-- Heaps -->
    <section class="mb-8">
      <h2 class="text-2xl font-semibold text-blue-500">10. Heaps</h2>
      <pre class="bg-gray-100 p-4 rounded-md mt-4 text-sm">
class MaxHeap<T> {
  private heap: T[] = [];

  insert(value: T): void {
    this.heap.push(value);
    this.bubbleUp();
  }

  extractMax(): T | undefined {
    const max = this.heap[0];
    const end = this.heap.pop();
    if (this.heap.length > 0 && end !== undefined) {
      this.heap[0] = end;
      this.bubbleDown();
    }
    return max;
  }

  private bubbleUp(): void {
    let index = this.heap.length - 1;
    const element = this.heap[index];
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      const parent = this.heap[parentIndex];
      if (parent >= element) break;
      this.heap[index] = parent;
      index = parentIndex;
    }
    this.heap[index] = element;
  }

  private bubbleDown(): void {
    let index = 0;
    const length = this.heap.length;
    const element = this.heap[0];
    while (true) {
      let leftChildIndex = 2 * index + 1;
      let rightChildIndex = 2 * index + 2;
      let swap: number | null = null;

      if (leftChildIndex < length) {
        const leftChild = this.heap[leftChildIndex];
        if (leftChild > element) {
          swap = leftChildIndex;
        }
      }
      if (rightChildIndex < length) {
        const rightChild = this.heap[rightChildIndex];
        if ((swap === null && rightChild > element) || (swap !== null && rightChild > this.heap[swap])) {
          swap = rightChildIndex;
        }
      }
      if (swap === null) break;
      this.heap[index] = this.heap[swap];
      this.heap[swap] = element;
      index = swap;
    }
  }
}

const maxHeap = new MaxHeap<number>();
maxHeap.insert(10);
maxHeap.insert(20);
maxHeap.insert(5);
console.log(maxHeap.extractMax()); // 20
      </pre>
    </section>

  </div>
</body>
</html>
